"""
Shared dataclasses for the ATLAS benchmark infrastructure.

This module defines the core data structures used throughout the benchmark system.
"""

from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any
from enum import Enum
import json


class TaskDifficulty(Enum):
    """Task difficulty levels."""
    EASY = "easy"
    MEDIUM = "medium"
    HARD = "hard"


class TaskCategory(Enum):
    """Task categories for the custom benchmark set."""
    ALGORITHM = "algorithm"
    DATA_PROCESSING = "data_processing"
    API_INTEGRATION = "api_integration"
    TEST_GENERATION = "test_generation"
    REFACTORING = "refactoring"
    BUG_FIXING = "bug_fixing"
    HUMANEVAL = "humaneval"
    MBPP = "mbpp"


@dataclass
class BenchmarkTask:
    """
    A single benchmark task.

    Attributes:
        task_id: Unique identifier for the task
        prompt: The task description/prompt given to the model
        canonical_solution: Reference implementation that passes all tests
        test_code: Python test code that validates the solution
        entry_point: The function name the model should implement
        category: Task category (algorithm, data_processing, etc.)
        difficulty: Task difficulty (easy, medium, hard)
        tags: List of descriptive tags
    """
    task_id: str
    prompt: str
    canonical_solution: str
    test_code: str
    entry_point: str
    category: str = "humaneval"
    difficulty: str = "medium"
    tags: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "task_id": self.task_id,
            "prompt": self.prompt,
            "canonical_solution": self.canonical_solution,
            "test_code": self.test_code,
            "entry_point": self.entry_point,
            "category": self.category,
            "difficulty": self.difficulty,
            "tags": self.tags
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "BenchmarkTask":
        """Create from dictionary."""
        return cls(
            task_id=data["task_id"],
            prompt=data["prompt"],
            canonical_solution=data["canonical_solution"],
            test_code=data["test_code"],
            entry_point=data["entry_point"],
            category=data.get("category", "humaneval"),
            difficulty=data.get("difficulty", "medium"),
            tags=data.get("tags", [])
        )


@dataclass
class AttemptResult:
    """
    Result of a single attempt at solving a task.

    Attributes:
        task_id: The task identifier
        attempt_number: Which attempt this is (1-indexed)
        generated_code: The code generated by the model
        passed: Whether the code passed all tests
        execution_time_ms: Time to execute the code
        error_output: Error message if execution failed
        tokens_generated: Number of tokens in the generated response
        inference_time_ms: Time for model inference
        stdout: Standard output from execution
        stderr: Standard error from execution
    """
    task_id: str
    attempt_number: int
    generated_code: str
    passed: bool
    execution_time_ms: float
    error_output: str = ""
    tokens_generated: int = 0
    inference_time_ms: float = 0.0
    stdout: str = ""
    stderr: str = ""

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "task_id": self.task_id,
            "attempt_number": self.attempt_number,
            "generated_code": self.generated_code,
            "passed": self.passed,
            "execution_time_ms": self.execution_time_ms,
            "error_output": self.error_output,
            "tokens_generated": self.tokens_generated,
            "inference_time_ms": self.inference_time_ms,
            "stdout": self.stdout,
            "stderr": self.stderr
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "AttemptResult":
        """Create from dictionary."""
        return cls(
            task_id=data["task_id"],
            attempt_number=data["attempt_number"],
            generated_code=data["generated_code"],
            passed=data["passed"],
            execution_time_ms=data["execution_time_ms"],
            error_output=data.get("error_output", ""),
            tokens_generated=data.get("tokens_generated", 0),
            inference_time_ms=data.get("inference_time_ms", 0.0),
            stdout=data.get("stdout", ""),
            stderr=data.get("stderr", "")
        )


@dataclass
class TaskResult:
    """
    Aggregated results for a single task across multiple attempts.

    Attributes:
        task_id: The task identifier
        attempts: List of individual attempt results
        best_attempt: The attempt number that passed (if any)
        total_inference_time_ms: Total time spent on inference
        total_execution_time_ms: Total time spent on execution
        total_tokens: Total tokens generated across all attempts
    """
    task_id: str
    attempts: List[AttemptResult] = field(default_factory=list)
    best_attempt: Optional[int] = None
    total_inference_time_ms: float = 0.0
    total_execution_time_ms: float = 0.0
    total_tokens: int = 0

    @property
    def passed(self) -> bool:
        """Whether any attempt passed."""
        return any(a.passed for a in self.attempts)

    @property
    def num_attempts(self) -> int:
        """Number of attempts made."""
        return len(self.attempts)

    @property
    def num_passed(self) -> int:
        """Number of passing attempts."""
        return sum(1 for a in self.attempts if a.passed)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "task_id": self.task_id,
            "attempts": [a.to_dict() for a in self.attempts],
            "best_attempt": self.best_attempt,
            "total_inference_time_ms": self.total_inference_time_ms,
            "total_execution_time_ms": self.total_execution_time_ms,
            "total_tokens": self.total_tokens,
            "passed": self.passed,
            "num_attempts": self.num_attempts,
            "num_passed": self.num_passed
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "TaskResult":
        """Create from dictionary."""
        result = cls(
            task_id=data["task_id"],
            attempts=[AttemptResult.from_dict(a) for a in data.get("attempts", [])],
            best_attempt=data.get("best_attempt"),
            total_inference_time_ms=data.get("total_inference_time_ms", 0.0),
            total_execution_time_ms=data.get("total_execution_time_ms", 0.0),
            total_tokens=data.get("total_tokens", 0)
        )
        return result


@dataclass
class BenchmarkRun:
    """
    A complete benchmark run.

    Attributes:
        run_id: Unique identifier for this run
        dataset: Name of the dataset (humaneval, mbpp, custom)
        k: Number of attempts per task
        temperature: Sampling temperature
        results: Task results indexed by task_id
        start_time: ISO timestamp when run started
        end_time: ISO timestamp when run ended
        hardware_info: Hardware/environment information
        resume_info: Resume metadata if run was resumed
    """
    run_id: str
    dataset: str
    k: int
    temperature: float
    results: Dict[str, TaskResult] = field(default_factory=dict)
    start_time: str = ""
    end_time: str = ""
    hardware_info: Dict[str, Any] = field(default_factory=dict)
    resume_info: Dict[str, Any] = field(default_factory=dict)

    @property
    def total_tasks(self) -> int:
        """Total number of tasks."""
        return len(self.results)

    @property
    def passed_tasks(self) -> int:
        """Number of tasks with at least one passing attempt."""
        return sum(1 for r in self.results.values() if r.passed)

    @property
    def pass_rate(self) -> float:
        """Overall pass rate."""
        if self.total_tasks == 0:
            return 0.0
        return self.passed_tasks / self.total_tasks

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        result = {
            "run_id": self.run_id,
            "dataset": self.dataset,
            "k": self.k,
            "temperature": self.temperature,
            "results": {k: v.to_dict() for k, v in self.results.items()},
            "start_time": self.start_time,
            "end_time": self.end_time,
            "hardware_info": self.hardware_info,
            "total_tasks": self.total_tasks,
            "passed_tasks": self.passed_tasks,
            "pass_rate": self.pass_rate
        }
        if self.resume_info:
            result["resume_info"] = self.resume_info
        return result

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "BenchmarkRun":
        """Create from dictionary."""
        return cls(
            run_id=data["run_id"],
            dataset=data["dataset"],
            k=data["k"],
            temperature=data["temperature"],
            results={k: TaskResult.from_dict(v) for k, v in data.get("results", {}).items()},
            start_time=data.get("start_time", ""),
            end_time=data.get("end_time", ""),
            hardware_info=data.get("hardware_info", {}),
            resume_info=data.get("resume_info", {})
        )

    def save(self, filepath: str) -> None:
        """Save run to JSON file."""
        with open(filepath, 'w') as f:
            json.dump(self.to_dict(), f, indent=2)

    @classmethod
    def load(cls, filepath: str) -> "BenchmarkRun":
        """Load run from JSON file."""
        with open(filepath, 'r') as f:
            return cls.from_dict(json.load(f))


@dataclass
class HardwareInfo:
    """
    Hardware and software environment information.

    Attributes:
        gpu_model: GPU model name
        gpu_vram_gb: GPU VRAM in GB
        gpu_driver_version: GPU driver version
        cuda_version: CUDA version
        cpu_model: CPU model name
        cpu_cores: Number of CPU cores
        ram_gb: System RAM in GB
        os_name: Operating system name
        kernel_version: OS kernel version
        k3s_version: K3s version
        llama_cpp_version: llama.cpp version/commit
        model_name: LLM model name
        model_quantization: Model quantization type
        context_length: Context length setting
        power_draw_watts: Current GPU power draw
    """
    gpu_model: str = ""
    gpu_vram_gb: float = 0.0
    gpu_driver_version: str = ""
    cuda_version: str = ""
    cpu_model: str = ""
    cpu_cores: int = 0
    ram_gb: float = 0.0
    os_name: str = ""
    kernel_version: str = ""
    k3s_version: str = ""
    llama_cpp_version: str = ""
    model_name: str = ""
    model_quantization: str = ""
    context_length: int = 0
    power_draw_watts: float = 0.0

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "gpu_model": self.gpu_model,
            "gpu_vram_gb": self.gpu_vram_gb,
            "gpu_driver_version": self.gpu_driver_version,
            "cuda_version": self.cuda_version,
            "cpu_model": self.cpu_model,
            "cpu_cores": self.cpu_cores,
            "ram_gb": self.ram_gb,
            "os_name": self.os_name,
            "kernel_version": self.kernel_version,
            "k3s_version": self.k3s_version,
            "llama_cpp_version": self.llama_cpp_version,
            "model_name": self.model_name,
            "model_quantization": self.model_quantization,
            "context_length": self.context_length,
            "power_draw_watts": self.power_draw_watts
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "HardwareInfo":
        """Create from dictionary."""
        return cls(**{k: v for k, v in data.items() if k in cls.__dataclass_fields__})
